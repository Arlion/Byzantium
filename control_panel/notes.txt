Use CherryPy for the web server.  It's probably packaged for whatever the live
distro is based off of.

When a client browses a URL served by a CherryPy instance, it is trivial to
execute code that does something.

http://www.cherrypy.org/wiki/CherryPyTutorial

Each execution thread should open a database handle as its first act, and close
it just before it dies.  Don't forget error handling!

Pick a templating system to do the HTML.  I suck at web design.
http://www.cherrypy.org/wiki/ChoosingATemplatingLanguage

Experimenting with python-mako.  I don't know what I'm doing yet.
http://www.makotemplates.org/docs/usage.html

By default, a CherryPy instance listens on localhost:8080 only.

Basic framework:
	import cherrypy
	import whatever else

	class <class of web app here>
		...
		<name of method to expost>.exposed = True

	cherrypy.quickstart(<class here>())

A method must be exposed if it's going to be used to handle HTTP requests.

Whatever a method return()s gets sent to the client.

Whatever a method return()s gets sent to the client.  This needs to be said
twice.  If you return() some plain text, that's all the browser gets.  Fully
formed HTML needs to be returned to actually send a web page.

CherryPy maps requests for URLs to objects and invokes exposed methods
automatically, as required.  That object can be an HTML file read from disk or
served, or it could be HTML code dynamically generated by the application server.

Config files can be written for the server.  It can presumably be reconfigured
at runtime in other ways, also.

/ == Application.root()

root = HelloWorld() == http://localhost/
root.fooble = fooble() == http://localhost/fooble/
root.rifle = Rifle() == http://localhost/rifle/

Methods on mounted application objects can be referenced elsewhere in the code.

The built-in method .index() handles URLs that end in a slash:
	/orders/items/ == root.orders.items.index()

Data from HTML forms can be acquired with keyword arguments.  A page that
implements a basic two-field authentication page called doLogin, with the fields
'username' and 'password' could be implemented this way:

class Root:
	def doLogin(self, username=None, password=None):
		do stuff..
	doLogin.exposed = True

Both GET and POST are supported.

If only a partial match of the URL succeeds, the application class' default()
method is called.  Ideally, default() only implements error handling or URL
positional argument processing.  It, of course, needs to be exposed.

The CherryPy config file format isn't too different from other Python config
files.

All GET and POST variables are passed to methods as parameters.  Where they came
from, their sizes and types, et al are irrelevant.  Defaults can be defined per
usual.

CherryPy always starts with the object Application.root() when trying to map a
request to an object.  Thus, a root handler is always required.

When displaying a page with a form, whatever variables the values entered go
into (like 'username' or 'idCode'), they will be returned in Python variables of
the same names so you can do stuff with them.

A CherryPy Tool (http://cherrypy.org/wiki/BuiltinTools) called 'staticdir' can
be used to serve static content out of a particular directory.  It is configured
in the app's config file, so you don't actually have to write any code for this.

Design the web app using the Mako templating engine along with HTML.
	mytemplate = Template(filename='/path/to/something.html')
	print mytemplate.render()
Add caching of generated Python code:
	mytemplate = Template(filename='/path/to/something.html'
		module_directory='/tmp/appcache')
	print mytemplate.render()

Put all Mako templates into a single directory and reference them automagically:
	from mako.template import Template
	from mako.lookup import TemplateLookup

	templatedir = TemplateLookup(directories=['/srv/templates'])
	template = Template(""" <$include file="page.html"> Hello, world! """,
		lookup=templatedir)

This example, when run and browsed, searches /srv/templates for the file
page.html.

Here, page.html is a text file consisting of some HTML with Mako-specific tags
that will be filled in by the web server when browsed.

The 'real' way of doing it is to build a helper method that takes a URL to a
template as an argument, searches the configured directories for the template,
insert the values of the variables passed to it, and return the whole shebang.
	from mako.template import Template
	from mako.lookup import TemplateLookup

	templatedir = TemplateLookup(directories=['/srv/templates'],
		module_directory='/tmp/app', collection_size=100)

	def serve_template(templatename, **kwargs):
		mytemplate = mylookup.get_template(templatename)
		print mytemplate.render(**kwargs)

note: the parameter collection_size is an integer specifying the maximum number
of precompiled templates to keep cached.  The oldest are purged.

Ultimately, Mako tags are just variable substitutions.  There aren't many tags
defined in the templating language itself, most of them are arbitrary.

Mako tags (variables) look like this: ${}

Everything inside the curly braces can be a Python expression, from a variable
to a bit of code.  For example:
	${title}
	${authors}
	${sidebar}
	${"This really could go into a variable."}
	${junkgenerator.produce()}
	${witty_quote()}
	${pow(x, 4)}
