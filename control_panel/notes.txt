Use CherryPy for the web server.  It's probably packaged for whatever the live
distro is based off of.

When a client browses a URL served by a CherryPy instance, it is trivial to
execute code that does something.

http://www.cherrypy.org/wiki/CherryPyTutorial

Each execution thread should open a database handle as its first act, and close
it just before it dies.  Don't forget error handling!

Pick a templating system to do the HTML.  I suck at web design.
http://www.cherrypy.org/wiki/ChoosingATemplatingLanguage

By default, a CherryPy instance listens on localhost:8080 only.

Basic framework:
	import cherrypy
	import whatever else

	class <class of web app here>
		...
		<name of method to expost>.exposed = True

	cherrypy.quickstart(<class here>())

A method must be exposed if it's going to be useed to handle HTTP requests.

CherryPy maps requests for URLs to objects and invokes exposed methods
automatically, as required.  That object can be an HTML file read from disk or
served, or it could be HTML code dynamically generated by the application server.

Config files can be written for the server.  It can presumably be reconfigured
at runtime in other ways, also.

/ == Application.root()

root = HelloWorld() == http://localhost/
root.fooble = fooble() == http://localhost/fooble/
root.rifle = Rifle() == http://localhost/rifle/

Methods on mounted application objects can be referenced elsewhere in the code.

The built-in method .index() handles URLs that end in a slash:
	/orders/items/ == root.orders.items.index()

Data from HTML forms can be acquired with keyword arguments.  A page that
implements a basic two-field authentication page called doLogin, with the fields
'username' and 'password' could be implemented this way:

class Root:
	def doLogin(self, username=None, password=None):
		do stuff..
	doLogin.exposed = True

Both GET and POST are supported.

If only a partial match of the URL succeeds, the application class' default()
method is called.  Ideally, default() only implements error handling or URL
positional argument processing.  It, of course, needs to be exposed.

The CherryPy config file format isn't too different from other Python config
files.
